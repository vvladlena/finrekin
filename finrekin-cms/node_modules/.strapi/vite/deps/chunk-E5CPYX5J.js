import {
  getRelationType
} from "./chunk-H4GPAAVJ.js";
import {
  require_escape_string_regexp
} from "./chunk-3GKSM22F.js";
import {
  require_pluralize
} from "./chunk-GGB7PTMN.js";
import {
  require_set
} from "./chunk-YLNBWDVZ.js";
import {
  require_merge,
  require_omit
} from "./chunk-EACNJOKI.js";
import {
  require_snakeCase
} from "./chunk-JNOVONHP.js";
import {
  require_arrayIncludes,
  require_noop
} from "./chunk-D2AJA42X.js";
import {
  createSlice
} from "./chunk-7JYK6TW6.js";
import {
  require_Set,
  require_SetCache,
  require_cacheHas,
  require_setToArray
} from "./chunk-HM5YIFDI.js";
import {
  e
} from "./chunk-QOUV5O5E.js";
import {
  Box,
  Flex,
  Link,
  Typography,
  useIntl
} from "./chunk-YQYM7WZ4.js";
import {
  require_react_dom
} from "./chunk-AWHRF5BE.js";
import {
  ForwardRef$2L,
  ForwardRef$2h
} from "./chunk-EXVE46AP.js";
import {
  require_jsx_runtime
} from "./chunk-LMPM4PM5.js";
import {
  dt,
  mt
} from "./chunk-3LBZKDTB.js";
import {
  require_react
} from "./chunk-D3I3COXH.js";
import {
  __commonJS,
  __toESM
} from "./chunk-LK32TJAX.js";

// node_modules/lodash.deburr/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.deburr/index.js"(exports, module) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    var deburredLetters = {
      // Latin-1 Supplement block.
      "Ã€": "A",
      "Ã": "A",
      "Ã‚": "A",
      "Ãƒ": "A",
      "Ã„": "A",
      "Ã…": "A",
      "Ã ": "a",
      "Ã¡": "a",
      "Ã¢": "a",
      "Ã£": "a",
      "Ã¤": "a",
      "Ã¥": "a",
      "Ã‡": "C",
      "Ã§": "c",
      "Ã": "D",
      "Ã°": "d",
      "Ãˆ": "E",
      "Ã‰": "E",
      "ÃŠ": "E",
      "Ã‹": "E",
      "Ã¨": "e",
      "Ã©": "e",
      "Ãª": "e",
      "Ã«": "e",
      "ÃŒ": "I",
      "Ã": "I",
      "ÃŽ": "I",
      "Ã": "I",
      "Ã¬": "i",
      "Ã­": "i",
      "Ã®": "i",
      "Ã¯": "i",
      "Ã‘": "N",
      "Ã±": "n",
      "Ã’": "O",
      "Ã“": "O",
      "Ã”": "O",
      "Ã•": "O",
      "Ã–": "O",
      "Ã˜": "O",
      "Ã²": "o",
      "Ã³": "o",
      "Ã´": "o",
      "Ãµ": "o",
      "Ã¶": "o",
      "Ã¸": "o",
      "Ã™": "U",
      "Ãš": "U",
      "Ã›": "U",
      "Ãœ": "U",
      "Ã¹": "u",
      "Ãº": "u",
      "Ã»": "u",
      "Ã¼": "u",
      "Ã": "Y",
      "Ã½": "y",
      "Ã¿": "y",
      "Ã†": "Ae",
      "Ã¦": "ae",
      "Ãž": "Th",
      "Ã¾": "th",
      "ÃŸ": "ss",
      // Latin Extended-A block.
      "Ä€": "A",
      "Ä‚": "A",
      "Ä„": "A",
      "Ä": "a",
      "Äƒ": "a",
      "Ä…": "a",
      "Ä†": "C",
      "Äˆ": "C",
      "ÄŠ": "C",
      "ÄŒ": "C",
      "Ä‡": "c",
      "Ä‰": "c",
      "Ä‹": "c",
      "Ä": "c",
      "ÄŽ": "D",
      "Ä": "D",
      "Ä": "d",
      "Ä‘": "d",
      "Ä’": "E",
      "Ä”": "E",
      "Ä–": "E",
      "Ä˜": "E",
      "Äš": "E",
      "Ä“": "e",
      "Ä•": "e",
      "Ä—": "e",
      "Ä™": "e",
      "Ä›": "e",
      "Äœ": "G",
      "Äž": "G",
      "Ä ": "G",
      "Ä¢": "G",
      "Ä": "g",
      "ÄŸ": "g",
      "Ä¡": "g",
      "Ä£": "g",
      "Ä¤": "H",
      "Ä¦": "H",
      "Ä¥": "h",
      "Ä§": "h",
      "Ä¨": "I",
      "Äª": "I",
      "Ä¬": "I",
      "Ä®": "I",
      "Ä°": "I",
      "Ä©": "i",
      "Ä«": "i",
      "Ä­": "i",
      "Ä¯": "i",
      "Ä±": "i",
      "Ä´": "J",
      "Äµ": "j",
      "Ä¶": "K",
      "Ä·": "k",
      "Ä¸": "k",
      "Ä¹": "L",
      "Ä»": "L",
      "Ä½": "L",
      "Ä¿": "L",
      "Å": "L",
      "Äº": "l",
      "Ä¼": "l",
      "Ä¾": "l",
      "Å€": "l",
      "Å‚": "l",
      "Åƒ": "N",
      "Å…": "N",
      "Å‡": "N",
      "ÅŠ": "N",
      "Å„": "n",
      "Å†": "n",
      "Åˆ": "n",
      "Å‹": "n",
      "ÅŒ": "O",
      "ÅŽ": "O",
      "Å": "O",
      "Å": "o",
      "Å": "o",
      "Å‘": "o",
      "Å”": "R",
      "Å–": "R",
      "Å˜": "R",
      "Å•": "r",
      "Å—": "r",
      "Å™": "r",
      "Åš": "S",
      "Åœ": "S",
      "Åž": "S",
      "Å ": "S",
      "Å›": "s",
      "Å": "s",
      "ÅŸ": "s",
      "Å¡": "s",
      "Å¢": "T",
      "Å¤": "T",
      "Å¦": "T",
      "Å£": "t",
      "Å¥": "t",
      "Å§": "t",
      "Å¨": "U",
      "Åª": "U",
      "Å¬": "U",
      "Å®": "U",
      "Å°": "U",
      "Å²": "U",
      "Å©": "u",
      "Å«": "u",
      "Å­": "u",
      "Å¯": "u",
      "Å±": "u",
      "Å³": "u",
      "Å´": "W",
      "Åµ": "w",
      "Å¶": "Y",
      "Å·": "y",
      "Å¸": "Y",
      "Å¹": "Z",
      "Å»": "Z",
      "Å½": "Z",
      "Åº": "z",
      "Å¼": "z",
      "Å¾": "z",
      "Ä²": "IJ",
      "Ä³": "ij",
      "Å’": "Oe",
      "Å“": "oe",
      "Å‰": "'n",
      "Å¿": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol = root.Symbol;
    var symbolProto = Symbol ? Symbol.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module.exports = deburr;
  }
});

// node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "node_modules/@sindresorhus/transliterate/node_modules/escape-string-regexp/index.js"(exports, module) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/@sindresorhus/transliterate/replacements.js
var require_replacements = __commonJS({
  "node_modules/@sindresorhus/transliterate/replacements.js"(exports, module) {
    "use strict";
    module.exports = [
      // German umlauts
      ["ÃŸ", "ss"],
      ["Ã¤", "ae"],
      ["Ã„", "Ae"],
      ["Ã¶", "oe"],
      ["Ã–", "Oe"],
      ["Ã¼", "ue"],
      ["Ãœ", "Ue"],
      // Latin
      ["Ã€", "A"],
      ["Ã", "A"],
      ["Ã‚", "A"],
      ["Ãƒ", "A"],
      ["Ã„", "Ae"],
      ["Ã…", "A"],
      ["Ã†", "AE"],
      ["Ã‡", "C"],
      ["Ãˆ", "E"],
      ["Ã‰", "E"],
      ["ÃŠ", "E"],
      ["Ã‹", "E"],
      ["ÃŒ", "I"],
      ["Ã", "I"],
      ["ÃŽ", "I"],
      ["Ã", "I"],
      ["Ã", "D"],
      ["Ã‘", "N"],
      ["Ã’", "O"],
      ["Ã“", "O"],
      ["Ã”", "O"],
      ["Ã•", "O"],
      ["Ã–", "Oe"],
      ["Å", "O"],
      ["Ã˜", "O"],
      ["Ã™", "U"],
      ["Ãš", "U"],
      ["Ã›", "U"],
      ["Ãœ", "Ue"],
      ["Å°", "U"],
      ["Ã", "Y"],
      ["Ãž", "TH"],
      ["ÃŸ", "ss"],
      ["Ã ", "a"],
      ["Ã¡", "a"],
      ["Ã¢", "a"],
      ["Ã£", "a"],
      ["Ã¤", "ae"],
      ["Ã¥", "a"],
      ["Ã¦", "ae"],
      ["Ã§", "c"],
      ["Ã¨", "e"],
      ["Ã©", "e"],
      ["Ãª", "e"],
      ["Ã«", "e"],
      ["Ã¬", "i"],
      ["Ã­", "i"],
      ["Ã®", "i"],
      ["Ã¯", "i"],
      ["Ã°", "d"],
      ["Ã±", "n"],
      ["Ã²", "o"],
      ["Ã³", "o"],
      ["Ã´", "o"],
      ["Ãµ", "o"],
      ["Ã¶", "oe"],
      ["Å‘", "o"],
      ["Ã¸", "o"],
      ["Ã¹", "u"],
      ["Ãº", "u"],
      ["Ã»", "u"],
      ["Ã¼", "ue"],
      ["Å±", "u"],
      ["Ã½", "y"],
      ["Ã¾", "th"],
      ["Ã¿", "y"],
      ["áºž", "SS"],
      // Vietnamese
      ["Ã ", "a"],
      ["Ã€", "A"],
      ["Ã¡", "a"],
      ["Ã", "A"],
      ["Ã¢", "a"],
      ["Ã‚", "A"],
      ["Ã£", "a"],
      ["Ãƒ", "A"],
      ["Ã¨", "e"],
      ["Ãˆ", "E"],
      ["Ã©", "e"],
      ["Ã‰", "E"],
      ["Ãª", "e"],
      ["ÃŠ", "E"],
      ["Ã¬", "i"],
      ["ÃŒ", "I"],
      ["Ã­", "i"],
      ["Ã", "I"],
      ["Ã²", "o"],
      ["Ã’", "O"],
      ["Ã³", "o"],
      ["Ã“", "O"],
      ["Ã´", "o"],
      ["Ã”", "O"],
      ["Ãµ", "o"],
      ["Ã•", "O"],
      ["Ã¹", "u"],
      ["Ã™", "U"],
      ["Ãº", "u"],
      ["Ãš", "U"],
      ["Ã½", "y"],
      ["Ã", "Y"],
      ["Äƒ", "a"],
      ["Ä‚", "A"],
      ["Ä", "D"],
      ["Ä‘", "d"],
      ["Ä©", "i"],
      ["Ä¨", "I"],
      ["Å©", "u"],
      ["Å¨", "U"],
      ["Æ¡", "o"],
      ["Æ ", "O"],
      ["Æ°", "u"],
      ["Æ¯", "U"],
      ["áº¡", "a"],
      ["áº ", "A"],
      ["áº£", "a"],
      ["áº¢", "A"],
      ["áº¥", "a"],
      ["áº¤", "A"],
      ["áº§", "a"],
      ["áº¦", "A"],
      ["áº©", "a"],
      ["áº¨", "A"],
      ["áº«", "a"],
      ["áºª", "A"],
      ["áº­", "a"],
      ["áº¬", "A"],
      ["áº¯", "a"],
      ["áº®", "A"],
      ["áº±", "a"],
      ["áº°", "A"],
      ["áº³", "a"],
      ["áº²", "A"],
      ["áºµ", "a"],
      ["áº´", "A"],
      ["áº·", "a"],
      ["áº¶", "A"],
      ["áº¹", "e"],
      ["áº¸", "E"],
      ["áº»", "e"],
      ["áºº", "E"],
      ["áº½", "e"],
      ["áº¼", "E"],
      ["áº¿", "e"],
      ["áº¾", "E"],
      ["á»", "e"],
      ["á»€", "E"],
      ["á»ƒ", "e"],
      ["á»‚", "E"],
      ["á»…", "e"],
      ["á»„", "E"],
      ["á»‡", "e"],
      ["á»†", "E"],
      ["á»‰", "i"],
      ["á»ˆ", "I"],
      ["á»‹", "i"],
      ["á»Š", "I"],
      ["á»", "o"],
      ["á»Œ", "O"],
      ["á»", "o"],
      ["á»Ž", "O"],
      ["á»‘", "o"],
      ["á»", "O"],
      ["á»“", "o"],
      ["á»’", "O"],
      ["á»•", "o"],
      ["á»”", "O"],
      ["á»—", "o"],
      ["á»–", "O"],
      ["á»™", "o"],
      ["á»˜", "O"],
      ["á»›", "o"],
      ["á»š", "O"],
      ["á»", "o"],
      ["á»œ", "O"],
      ["á»Ÿ", "o"],
      ["á»ž", "O"],
      ["á»¡", "o"],
      ["á» ", "O"],
      ["á»£", "o"],
      ["á»¢", "O"],
      ["á»¥", "u"],
      ["á»¤", "U"],
      ["á»§", "u"],
      ["á»¦", "U"],
      ["á»©", "u"],
      ["á»¨", "U"],
      ["á»«", "u"],
      ["á»ª", "U"],
      ["á»­", "u"],
      ["á»¬", "U"],
      ["á»¯", "u"],
      ["á»®", "U"],
      ["á»±", "u"],
      ["á»°", "U"],
      ["á»³", "y"],
      ["á»²", "Y"],
      ["á»µ", "y"],
      ["á»´", "Y"],
      ["á»·", "y"],
      ["á»¶", "Y"],
      ["á»¹", "y"],
      ["á»¸", "Y"],
      // Arabic
      ["Ø¡", "e"],
      ["Ø¢", "a"],
      ["Ø£", "a"],
      ["Ø¤", "w"],
      ["Ø¥", "i"],
      ["Ø¦", "y"],
      ["Ø§", "a"],
      ["Ø¨", "b"],
      ["Ø©", "t"],
      ["Øª", "t"],
      ["Ø«", "th"],
      ["Ø¬", "j"],
      ["Ø­", "h"],
      ["Ø®", "kh"],
      ["Ø¯", "d"],
      ["Ø°", "dh"],
      ["Ø±", "r"],
      ["Ø²", "z"],
      ["Ø³", "s"],
      ["Ø´", "sh"],
      ["Øµ", "s"],
      ["Ø¶", "d"],
      ["Ø·", "t"],
      ["Ø¸", "z"],
      ["Ø¹", "e"],
      ["Øº", "gh"],
      ["Ù€", "_"],
      ["Ù", "f"],
      ["Ù‚", "q"],
      ["Ùƒ", "k"],
      ["Ù„", "l"],
      ["Ù…", "m"],
      ["Ù†", "n"],
      ["Ù‡", "h"],
      ["Ùˆ", "w"],
      ["Ù‰", "a"],
      ["ÙŠ", "y"],
      ["ÙŽâ€Ž", "a"],
      ["Ù", "u"],
      ["Ùâ€Ž", "i"],
      ["Ù ", "0"],
      ["Ù¡", "1"],
      ["Ù¢", "2"],
      ["Ù£", "3"],
      ["Ù¤", "4"],
      ["Ù¥", "5"],
      ["Ù¦", "6"],
      ["Ù§", "7"],
      ["Ù¨", "8"],
      ["Ù©", "9"],
      // Persian / Farsi
      ["Ú†", "ch"],
      ["Ú©", "k"],
      ["Ú¯", "g"],
      ["Ù¾", "p"],
      ["Ú˜", "zh"],
      ["ÛŒ", "y"],
      ["Û°", "0"],
      ["Û±", "1"],
      ["Û²", "2"],
      ["Û³", "3"],
      ["Û´", "4"],
      ["Ûµ", "5"],
      ["Û¶", "6"],
      ["Û·", "7"],
      ["Û¸", "8"],
      ["Û¹", "9"],
      // Pashto
      ["Ù¼", "p"],
      ["Ú", "z"],
      ["Ú…", "c"],
      ["Ú‰", "d"],
      ["ïº«", "d"],
      ["ïº­", "r"],
      ["Ú“", "r"],
      ["ïº¯", "z"],
      ["Ú–", "g"],
      ["Úš", "x"],
      ["Ú«", "g"],
      ["Ú¼", "n"],
      ["Û€", "e"],
      ["Û", "e"],
      ["Û", "ai"],
      // Urdu
      ["Ù¹", "t"],
      ["Úˆ", "d"],
      ["Ú‘", "r"],
      ["Úº", "n"],
      ["Û", "h"],
      ["Ú¾", "h"],
      ["Û’", "e"],
      // Russian
      ["Ð", "A"],
      ["Ð°", "a"],
      ["Ð‘", "B"],
      ["Ð±", "b"],
      ["Ð’", "V"],
      ["Ð²", "v"],
      ["Ð“", "G"],
      ["Ð³", "g"],
      ["Ð”", "D"],
      ["Ð´", "d"],
      ["Ð•", "E"],
      ["Ðµ", "e"],
      ["Ð–", "Zh"],
      ["Ð¶", "zh"],
      ["Ð—", "Z"],
      ["Ð·", "z"],
      ["Ð˜", "I"],
      ["Ð¸", "i"],
      ["Ð™", "J"],
      ["Ð¹", "j"],
      ["Ðš", "K"],
      ["Ðº", "k"],
      ["Ð›", "L"],
      ["Ð»", "l"],
      ["Ðœ", "M"],
      ["Ð¼", "m"],
      ["Ð", "N"],
      ["Ð½", "n"],
      ["Ðž", "O"],
      ["Ð¾", "o"],
      ["ÐŸ", "P"],
      ["Ð¿", "p"],
      ["Ð ", "R"],
      ["Ñ€", "r"],
      ["Ð¡", "S"],
      ["Ñ", "s"],
      ["Ð¢", "T"],
      ["Ñ‚", "t"],
      ["Ð£", "U"],
      ["Ñƒ", "u"],
      ["Ð¤", "F"],
      ["Ñ„", "f"],
      ["Ð¥", "H"],
      ["Ñ…", "h"],
      ["Ð¦", "Cz"],
      ["Ñ†", "cz"],
      ["Ð§", "Ch"],
      ["Ñ‡", "ch"],
      ["Ð¨", "Sh"],
      ["Ñˆ", "sh"],
      ["Ð©", "Shh"],
      ["Ñ‰", "shh"],
      ["Ðª", ""],
      ["ÑŠ", ""],
      ["Ð«", "Y"],
      ["Ñ‹", "y"],
      ["Ð¬", ""],
      ["ÑŒ", ""],
      ["Ð­", "E"],
      ["Ñ", "e"],
      ["Ð®", "Yu"],
      ["ÑŽ", "yu"],
      ["Ð¯", "Ya"],
      ["Ñ", "ya"],
      ["Ð", "Yo"],
      ["Ñ‘", "yo"],
      // Romanian
      ["Äƒ", "a"],
      ["Ä‚", "A"],
      ["È™", "s"],
      ["È˜", "S"],
      ["È›", "t"],
      ["Èš", "T"],
      ["Å£", "t"],
      ["Å¢", "T"],
      // Turkish
      ["ÅŸ", "s"],
      ["Åž", "S"],
      ["Ã§", "c"],
      ["Ã‡", "C"],
      ["ÄŸ", "g"],
      ["Äž", "G"],
      ["Ä±", "i"],
      ["Ä°", "I"],
      // Armenian
      ["Õ¡", "a"],
      ["Ô±", "A"],
      ["Õ¢", "b"],
      ["Ô²", "B"],
      ["Õ£", "g"],
      ["Ô³", "G"],
      ["Õ¤", "d"],
      ["Ô´", "D"],
      ["Õ¥", "ye"],
      ["Ôµ", "Ye"],
      ["Õ¦", "z"],
      ["Ô¶", "Z"],
      ["Õ§", "e"],
      ["Ô·", "E"],
      ["Õ¨", "y"],
      ["Ô¸", "Y"],
      ["Õ©", "t"],
      ["Ô¹", "T"],
      ["Õª", "zh"],
      ["Ôº", "Zh"],
      ["Õ«", "i"],
      ["Ô»", "I"],
      ["Õ¬", "l"],
      ["Ô¼", "L"],
      ["Õ­", "kh"],
      ["Ô½", "Kh"],
      ["Õ®", "ts"],
      ["Ô¾", "Ts"],
      ["Õ¯", "k"],
      ["Ô¿", "K"],
      ["Õ°", "h"],
      ["Õ€", "H"],
      ["Õ±", "dz"],
      ["Õ", "Dz"],
      ["Õ²", "gh"],
      ["Õ‚", "Gh"],
      ["Õ³", "tch"],
      ["Õƒ", "Tch"],
      ["Õ´", "m"],
      ["Õ„", "M"],
      ["Õµ", "y"],
      ["Õ…", "Y"],
      ["Õ¶", "n"],
      ["Õ†", "N"],
      ["Õ·", "sh"],
      ["Õ‡", "Sh"],
      ["Õ¸", "vo"],
      ["Õˆ", "Vo"],
      ["Õ¹", "ch"],
      ["Õ‰", "Ch"],
      ["Õº", "p"],
      ["ÕŠ", "P"],
      ["Õ»", "j"],
      ["Õ‹", "J"],
      ["Õ¼", "r"],
      ["ÕŒ", "R"],
      ["Õ½", "s"],
      ["Õ", "S"],
      ["Õ¾", "v"],
      ["ÕŽ", "V"],
      ["Õ¿", "t"],
      ["Õ", "T"],
      ["Ö€", "r"],
      ["Õ", "R"],
      ["Ö", "c"],
      ["Õ‘", "C"],
      ["Õ¸Ö‚", "u"],
      ["ÕˆÕ’", "U"],
      ["ÕˆÖ‚", "U"],
      ["Öƒ", "p"],
      ["Õ“", "P"],
      ["Ö„", "q"],
      ["Õ”", "Q"],
      ["Ö…", "o"],
      ["Õ•", "O"],
      ["Ö†", "f"],
      ["Õ–", "F"],
      ["Ö‡", "yev"],
      // Georgian
      ["áƒ", "a"],
      ["áƒ‘", "b"],
      ["áƒ’", "g"],
      ["áƒ“", "d"],
      ["áƒ”", "e"],
      ["áƒ•", "v"],
      ["áƒ–", "z"],
      ["áƒ—", "t"],
      ["áƒ˜", "i"],
      ["áƒ™", "k"],
      ["áƒš", "l"],
      ["áƒ›", "m"],
      ["áƒœ", "n"],
      ["áƒ", "o"],
      ["áƒž", "p"],
      ["áƒŸ", "zh"],
      ["áƒ ", "r"],
      ["áƒ¡", "s"],
      ["áƒ¢", "t"],
      ["áƒ£", "u"],
      ["áƒ¤", "ph"],
      ["áƒ¥", "q"],
      ["áƒ¦", "gh"],
      ["áƒ§", "k"],
      ["áƒ¨", "sh"],
      ["áƒ©", "ch"],
      ["áƒª", "ts"],
      ["áƒ«", "dz"],
      ["áƒ¬", "ts"],
      ["áƒ­", "tch"],
      ["áƒ®", "kh"],
      ["áƒ¯", "j"],
      ["áƒ°", "h"],
      // Czech
      ["Ä", "c"],
      ["Ä", "d"],
      ["Ä›", "e"],
      ["Åˆ", "n"],
      ["Å™", "r"],
      ["Å¡", "s"],
      ["Å¥", "t"],
      ["Å¯", "u"],
      ["Å¾", "z"],
      ["ÄŒ", "C"],
      ["ÄŽ", "D"],
      ["Äš", "E"],
      ["Å‡", "N"],
      ["Å˜", "R"],
      ["Å ", "S"],
      ["Å¤", "T"],
      ["Å®", "U"],
      ["Å½", "Z"],
      // Dhivehi
      ["Þ€", "h"],
      ["Þ", "sh"],
      ["Þ‚", "n"],
      ["Þƒ", "r"],
      ["Þ„", "b"],
      ["Þ…", "lh"],
      ["Þ†", "k"],
      ["Þ‡", "a"],
      ["Þˆ", "v"],
      ["Þ‰", "m"],
      ["ÞŠ", "f"],
      ["Þ‹", "dh"],
      ["ÞŒ", "th"],
      ["Þ", "l"],
      ["ÞŽ", "g"],
      ["Þ", "gn"],
      ["Þ", "s"],
      ["Þ‘", "d"],
      ["Þ’", "z"],
      ["Þ“", "t"],
      ["Þ”", "y"],
      ["Þ•", "p"],
      ["Þ–", "j"],
      ["Þ—", "ch"],
      ["Þ˜", "tt"],
      ["Þ™", "hh"],
      ["Þš", "kh"],
      ["Þ›", "th"],
      ["Þœ", "z"],
      ["Þ", "sh"],
      ["Þž", "s"],
      ["ÞŸ", "d"],
      ["Þ ", "t"],
      ["Þ¡", "z"],
      ["Þ¢", "a"],
      ["Þ£", "gh"],
      ["Þ¤", "q"],
      ["Þ¥", "w"],
      ["Þ¦", "a"],
      ["Þ§", "aa"],
      ["Þ¨", "i"],
      ["Þ©", "ee"],
      ["Þª", "u"],
      ["Þ«", "oo"],
      ["Þ¬", "e"],
      ["Þ­", "ey"],
      ["Þ®", "o"],
      ["Þ¯", "oa"],
      ["Þ°", ""],
      // Greek
      ["Î±", "a"],
      ["Î²", "v"],
      ["Î³", "g"],
      ["Î´", "d"],
      ["Îµ", "e"],
      ["Î¶", "z"],
      ["Î·", "i"],
      ["Î¸", "th"],
      ["Î¹", "i"],
      ["Îº", "k"],
      ["Î»", "l"],
      ["Î¼", "m"],
      ["Î½", "n"],
      ["Î¾", "ks"],
      ["Î¿", "o"],
      ["Ï€", "p"],
      ["Ï", "r"],
      ["Ïƒ", "s"],
      ["Ï„", "t"],
      ["Ï…", "y"],
      ["Ï†", "f"],
      ["Ï‡", "x"],
      ["Ïˆ", "ps"],
      ["Ï‰", "o"],
      ["Î¬", "a"],
      ["Î­", "e"],
      ["Î¯", "i"],
      ["ÏŒ", "o"],
      ["Ï", "y"],
      ["Î®", "i"],
      ["ÏŽ", "o"],
      ["Ï‚", "s"],
      ["ÏŠ", "i"],
      ["Î°", "y"],
      ["Ï‹", "y"],
      ["Î", "i"],
      ["Î‘", "A"],
      ["Î’", "B"],
      ["Î“", "G"],
      ["Î”", "D"],
      ["Î•", "E"],
      ["Î–", "Z"],
      ["Î—", "I"],
      ["Î˜", "TH"],
      ["Î™", "I"],
      ["Îš", "K"],
      ["Î›", "L"],
      ["Îœ", "M"],
      ["Î", "N"],
      ["Îž", "KS"],
      ["ÎŸ", "O"],
      ["Î ", "P"],
      ["Î¡", "R"],
      ["Î£", "S"],
      ["Î¤", "T"],
      ["Î¥", "Y"],
      ["Î¦", "F"],
      ["Î§", "X"],
      ["Î¨", "PS"],
      ["Î©", "O"],
      ["Î†", "A"],
      ["Îˆ", "E"],
      ["ÎŠ", "I"],
      ["ÎŒ", "O"],
      ["ÎŽ", "Y"],
      ["Î‰", "I"],
      ["Î", "O"],
      ["Îª", "I"],
      ["Î«", "Y"],
      // Disabled as it conflicts with German and Latin.
      // Hungarian
      // ['Ã¤', 'a'],
      // ['Ã„', 'A'],
      // ['Ã¶', 'o'],
      // ['Ã–', 'O'],
      // ['Ã¼', 'u'],
      // ['Ãœ', 'U'],
      // ['Å±', 'u'],
      // ['Å°', 'U'],
      // Latvian
      ["Ä", "a"],
      ["Ä“", "e"],
      ["Ä£", "g"],
      ["Ä«", "i"],
      ["Ä·", "k"],
      ["Ä¼", "l"],
      ["Å†", "n"],
      ["Å«", "u"],
      ["Ä€", "A"],
      ["Ä’", "E"],
      ["Ä¢", "G"],
      ["Äª", "I"],
      ["Ä¶", "K"],
      ["Ä»", "L"],
      ["Å…", "N"],
      ["Åª", "U"],
      ["Ä", "c"],
      ["Å¡", "s"],
      ["Å¾", "z"],
      ["ÄŒ", "C"],
      ["Å ", "S"],
      ["Å½", "Z"],
      // Lithuanian
      ["Ä…", "a"],
      ["Ä", "c"],
      ["Ä™", "e"],
      ["Ä—", "e"],
      ["Ä¯", "i"],
      ["Å¡", "s"],
      ["Å³", "u"],
      ["Å«", "u"],
      ["Å¾", "z"],
      ["Ä„", "A"],
      ["ÄŒ", "C"],
      ["Ä˜", "E"],
      ["Ä–", "E"],
      ["Ä®", "I"],
      ["Å ", "S"],
      ["Å²", "U"],
      ["Åª", "U"],
      // Macedonian
      ["ÐŒ", "Kj"],
      ["Ñœ", "kj"],
      ["Ð‰", "Lj"],
      ["Ñ™", "lj"],
      ["ÐŠ", "Nj"],
      ["Ñš", "nj"],
      ["Ð¢Ñ", "Ts"],
      ["Ñ‚Ñ", "ts"],
      // Polish
      ["Ä…", "a"],
      ["Ä‡", "c"],
      ["Ä™", "e"],
      ["Å‚", "l"],
      ["Å„", "n"],
      ["Å›", "s"],
      ["Åº", "z"],
      ["Å¼", "z"],
      ["Ä„", "A"],
      ["Ä†", "C"],
      ["Ä˜", "E"],
      ["Å", "L"],
      ["Åƒ", "N"],
      ["Åš", "S"],
      ["Å¹", "Z"],
      ["Å»", "Z"],
      // Disabled as it conflicts with Vietnamese.
      // Serbian
      // ['Ñ™', 'lj'],
      // ['Ñš', 'nj'],
      // ['Ð‰', 'Lj'],
      // ['ÐŠ', 'Nj'],
      // ['Ä‘', 'dj'],
      // ['Ä', 'Dj'],
      // ['Ñ’', 'dj'],
      // ['Ñ˜', 'j'],
      // ['Ñ›', 'c'],
      // ['ÑŸ', 'dz'],
      // ['Ð‚', 'Dj'],
      // ['Ðˆ', 'j'],
      // ['Ð‹', 'C'],
      // ['Ð', 'Dz'],
      // Disabled as it conflicts with German and Latin.
      // Slovak
      // ['Ã¤', 'a'],
      // ['Ã„', 'A'],
      // ['Ä¾', 'l'],
      // ['Äº', 'l'],
      // ['Å•', 'r'],
      // ['Ä½', 'L'],
      // ['Ä¹', 'L'],
      // ['Å”', 'R'],
      // Disabled as it conflicts with German and Latin.
      // Swedish
      // ['Ã¥', 'o'],
      // ['Ã…', 'o'],
      // ['Ã¤', 'a'],
      // ['Ã„', 'A'],
      // ['Ã«', 'e'],
      // ['Ã‹', 'E'],
      // ['Ã¶', 'o'],
      // ['Ã–', 'O'],
      // Ukrainian
      ["Ð„", "Ye"],
      ["Ð†", "I"],
      ["Ð‡", "Yi"],
      ["Ò", "G"],
      ["Ñ”", "ye"],
      ["Ñ–", "i"],
      ["Ñ—", "yi"],
      ["Ò‘", "g"]
      // Danish
      // ['Ã†', 'Ae'],
      // ['Ã˜', 'Oe'],
      // ['Ã…', 'Aa'],
      // ['Ã¦', 'ae'],
      // ['Ã¸', 'oe'],
      // ['Ã¥', 'aa']
    ];
  }
});

// node_modules/@sindresorhus/transliterate/index.js
var require_transliterate = __commonJS({
  "node_modules/@sindresorhus/transliterate/index.js"(exports, module) {
    "use strict";
    var deburr = require_lodash();
    var escapeStringRegexp = require_escape_string_regexp2();
    var builtinReplacements = require_replacements();
    var doCustomReplacements = (string, replacements) => {
      for (const [key, value] of replacements) {
        string = string.replace(new RegExp(escapeStringRegexp(key), "g"), value);
      }
      return string;
    };
    module.exports = (string, options) => {
      if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
      }
      options = {
        customReplacements: [],
        ...options
      };
      const customReplacements = new Map([
        ...builtinReplacements,
        ...options.customReplacements
      ]);
      string = string.normalize();
      string = doCustomReplacements(string, customReplacements);
      string = deburr(string);
      return string;
    };
  }
});

// node_modules/@sindresorhus/slugify/overridable-replacements.js
var require_overridable_replacements = __commonJS({
  "node_modules/@sindresorhus/slugify/overridable-replacements.js"(exports, module) {
    "use strict";
    module.exports = [
      ["&", " and "],
      ["ðŸ¦„", " unicorn "],
      ["â™¥", " love "]
    ];
  }
});

// node_modules/@sindresorhus/slugify/index.js
var require_slugify = __commonJS({
  "node_modules/@sindresorhus/slugify/index.js"(exports, module) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var transliterate = require_transliterate();
    var builtinOverridableReplacements = require_overridable_replacements();
    var decamelize = (string) => {
      return string.replace(/([A-Z]{2,})(\d+)/g, "$1 $2").replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2").replace(/([a-z\d])([A-Z])/g, "$1 $2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1 $2");
    };
    var removeMootSeparators = (string, separator) => {
      const escapedSeparator = escapeStringRegexp(separator);
      return string.replace(new RegExp(`${escapedSeparator}{2,}`, "g"), separator).replace(new RegExp(`^${escapedSeparator}|${escapedSeparator}$`, "g"), "");
    };
    var slugify2 = (string, options) => {
      if (typeof string !== "string") {
        throw new TypeError(`Expected a string, got \`${typeof string}\``);
      }
      options = {
        separator: "-",
        lowercase: true,
        decamelize: true,
        customReplacements: [],
        preserveLeadingUnderscore: false,
        ...options
      };
      const shouldPrependUnderscore = options.preserveLeadingUnderscore && string.startsWith("_");
      const customReplacements = new Map([
        ...builtinOverridableReplacements,
        ...options.customReplacements
      ]);
      string = transliterate(string, { customReplacements });
      if (options.decamelize) {
        string = decamelize(string);
      }
      let patternSlug = /[^a-zA-Z\d]+/g;
      if (options.lowercase) {
        string = string.toLowerCase();
        patternSlug = /[^a-z\d]+/g;
      }
      string = string.replace(patternSlug, options.separator);
      string = string.replace(/\\/g, "");
      if (options.separator) {
        string = removeMootSeparators(string, options.separator);
      }
      if (shouldPrependUnderscore) {
        string = `_${string}`;
      }
      return string;
    };
    var counter = () => {
      const occurrences = /* @__PURE__ */ new Map();
      const countable = (string, options) => {
        string = slugify2(string, options);
        if (!string) {
          return "";
        }
        const stringLower = string.toLowerCase();
        const numberless = occurrences.get(stringLower.replace(/(?:-\d+?)+?$/, "")) || 0;
        const counter2 = occurrences.get(stringLower);
        occurrences.set(stringLower, typeof counter2 === "number" ? counter2 + 1 : 1);
        const newCounter = occurrences.get(stringLower) || 2;
        if (newCounter >= 2 || numberless > 2) {
          string = `${string}-${newCounter}`;
        }
        return string;
      };
      countable.reset = () => {
        occurrences.clear();
      };
      return countable;
    };
    module.exports = slugify2;
    module.exports.counter = counter;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports, module) {
    var Set2 = require_Set();
    var noop = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    module.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set2 = iteratee ? null : createSet(array);
        if (set2) {
          return setToArray(set2);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseUniq;
  }
});

// node_modules/@strapi/content-type-builder/dist/admin/constants.mjs
var PERMISSIONS = {
  // This permission regards the main component (App) and is used to tell
  // If the plugin link should be displayed in the menu
  // And also if the plugin is accessible. This use case is found when a user types the url of the
  // plugin directly in the browser
  main: [
    {
      action: "plugin::content-type-builder.read",
      subject: null
    }
  ]
};
var MAX_COMPONENT_DEPTH = 6;

// node_modules/@strapi/content-type-builder/dist/admin/components/AutoReloadOverlayBlocker.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var React = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var AutoReloadOverlayBlockerContext = React.createContext({
  lockAppWithAutoreload: () => {
  },
  unlockAppWithAutoreload: () => {
  }
});
var MAX_ELAPSED_TIME = 300 * 1e3;
var AutoReloadOverlayBlockerProvider = ({ children }) => {
  const [isOpen, setIsOpen] = React.useState(false);
  const [config, setConfig] = React.useState({});
  const [failed, setFailed] = React.useState(false);
  const lockAppWithAutoreload = React.useCallback((config2 = {}) => {
    setIsOpen(true);
    setConfig(config2);
  }, []);
  const unlockAppWithAutoreload = React.useCallback(() => {
    setIsOpen(false);
    setConfig({});
  }, []);
  React.useEffect(() => {
    if (isOpen) {
      const timeout = setTimeout(() => {
        setFailed(true);
      }, MAX_ELAPSED_TIME);
      return () => {
        clearTimeout(timeout);
      };
    }
  }, [
    isOpen
  ]);
  let displayedIcon = (config == null ? void 0 : config.icon) || "reload";
  let description = {
    id: (config == null ? void 0 : config.description) || "components.OverlayBlocker.description",
    defaultMessage: "You're using a feature that needs the server to restart. The page will reload automatically."
  };
  let title = {
    id: (config == null ? void 0 : config.title) || "components.OverlayBlocker.title",
    defaultMessage: "Waiting for restart"
  };
  if (failed) {
    displayedIcon = "time";
    description = {
      id: "components.OverlayBlocker.description.serverError",
      defaultMessage: "The server should have restarted, please check your logs in the terminal."
    };
    title = {
      id: "components.OverlayBlocker.title.serverError",
      defaultMessage: "The restart is taking longer than expected"
    };
  }
  const autoReloadValue = React.useMemo(() => ({
    lockAppWithAutoreload,
    unlockAppWithAutoreload
  }), [
    lockAppWithAutoreload,
    unlockAppWithAutoreload
  ]);
  return (0, import_jsx_runtime.jsxs)(AutoReloadOverlayBlockerContext.Provider, {
    value: autoReloadValue,
    children: [
      (0, import_jsx_runtime.jsx)(Blocker, {
        displayedIcon,
        isOpen,
        description,
        title
      }),
      children
    ]
  });
};
var Blocker = ({ displayedIcon, description, title, isOpen }) => {
  var _a;
  const { formatMessage } = useIntl();
  return isOpen && ((_a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : _a.body) ? (0, import_react_dom.createPortal)(
    (0, import_jsx_runtime.jsxs)(Overlay, {
      id: "autoReloadOverlayBlocker",
      direction: "column",
      alignItems: "center",
      gap: 6,
      children: [
        (0, import_jsx_runtime.jsxs)(Flex, {
          direction: "column",
          alignItems: "center",
          gap: 2,
          children: [
            (0, import_jsx_runtime.jsx)(Typography, {
              tag: "h1",
              variant: "alpha",
              children: formatMessage(title)
            }),
            (0, import_jsx_runtime.jsx)(Typography, {
              tag: "h2",
              textColor: "neutral600",
              fontSize: 4,
              fontWeight: "regular",
              children: formatMessage(description)
            })
          ]
        }),
        displayedIcon === "reload" && (0, import_jsx_runtime.jsx)(IconBox, {
          padding: 6,
          background: "primary100",
          borderColor: "primary200",
          children: (0, import_jsx_runtime.jsx)(LoaderReload, {
            width: "4rem",
            height: "4rem"
          })
        }),
        displayedIcon === "time" && (0, import_jsx_runtime.jsx)(IconBox, {
          padding: 6,
          background: "primary100",
          borderColor: "primary200",
          children: (0, import_jsx_runtime.jsx)(ForwardRef$2h, {
            width: "4rem",
            height: "4rem"
          })
        }),
        (0, import_jsx_runtime.jsx)(Box, {
          marginTop: 2,
          children: (0, import_jsx_runtime.jsx)(Link, {
            href: "https://docs.strapi.io",
            isExternal: true,
            children: formatMessage({
              id: "global.documentation",
              defaultMessage: "Read the documentation"
            })
          })
        })
      ]
    }),
    // eslint-disable-next-line no-undef
    globalThis.document.body
  ) : null;
};
var rotation = mt`
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(359deg);
    }
  `;
var LoaderReload = dt(ForwardRef$2L)`
  animation: ${rotation} 1s infinite linear;
`;
var Overlay = dt(Flex)`
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  /* TODO: set this up in the theme for consistence z-index values */
  z-index: 1140;
  padding-top: 16rem;

  & > * {
    position: relative;
    z-index: 1;
  }

  &:before {
    content: '';
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background: ${({ theme }) => theme.colors.neutral0};
    opacity: 0.9;
  }
`;
var IconBox = dt(Box)`
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  svg {
    > path {
      fill: ${({ theme }) => theme.colors.primary600} !important;
    }
  }
`;
var useAutoReloadOverlayBlocker = () => React.useContext(AutoReloadOverlayBlockerContext);

// node_modules/@strapi/content-type-builder/dist/admin/components/DataManager/reducer.mjs
var import_merge = __toESM(require_merge(), 1);
var import_omit = __toESM(require_omit(), 1);

// node_modules/@strapi/content-type-builder/dist/admin/utils/makeUnique.mjs
var makeUnique = (array) => [
  ...new Set(array)
];

// node_modules/@strapi/content-type-builder/dist/admin/components/DataManager/undoRedo.mjs
var isCallable = (obj) => {
  return typeof obj === "function";
};
var createUndoRedoSlice = (sliceOpts, opts) => {
  const initialState3 = {
    past: [],
    future: [],
    current: isCallable(sliceOpts.initialState) ? sliceOpts.initialState() : sliceOpts.initialState
  };
  const { limit = 10 } = opts ?? {};
  const selector = opts.stateSelector || ((state) => state);
  const wrappedReducers = Object.keys(sliceOpts.reducers).reduce((acc, actionName) => {
    const reducer3 = sliceOpts.reducers[actionName];
    if (!isCallable(reducer3)) {
      throw new Error("Reducer must be a function. prepapre not support in UndoRedo wrapper");
    }
    acc[actionName] = (state, action) => {
      var _a;
      const newCurrent = reducer3(state.current, action);
      if ((_a = opts.excludeActionsFromHistory) == null ? void 0 : _a.includes(actionName)) {
        if (newCurrent !== void 0) {
          state.current = newCurrent;
        }
        return;
      }
      const originalCurrent = e(state.current);
      state.past.push(selector(originalCurrent));
      if (state.past.length > limit) {
        state.past.shift();
      }
      state.future = [];
      if (newCurrent !== void 0) {
        state.current = newCurrent;
      }
    };
    return acc;
  }, {});
  return createSlice({
    name: sliceOpts.name,
    initialState: initialState3,
    // @ts-expect-error - TS doesn't like the fact that we're adding extra reducers
    reducers: {
      ...wrappedReducers,
      undo: (state) => {
        if (state.past.length === 0) {
          return;
        }
        const previous = state.past.pop();
        if (previous !== void 0) {
          state.future = [
            state.current,
            ...state.future
          ];
          state.current = {
            ...state.current,
            ...previous
          };
        }
      },
      redo: (state) => {
        if (state.future.length === 0) {
          return;
        }
        const next = state.future.shift();
        if (next != void 0) {
          state.past = [
            ...state.past,
            state.current
          ];
          state.current = {
            ...state.current,
            ...next
          };
        }
      },
      discardAll: (state) => {
        if (opts.discard) {
          opts.discard(state.current);
        } else {
          state.current = initialState3.current;
        }
        state.past = [];
        state.future = [];
      },
      clearHistory: (state) => {
        state.past = [];
        state.future = [];
      }
    }
  });
};

// node_modules/@strapi/content-type-builder/dist/admin/components/DataManager/reducer.mjs
var initialState = {
  components: {},
  contentTypes: {},
  initialComponents: {},
  initialContentTypes: {},
  reservedNames: {
    models: [],
    attributes: []
  },
  isLoading: true
};
var ONE_SIDE_RELATIONS = [
  "oneWay",
  "manyWay"
];
var getOppositeRelation = (originalRelation) => {
  if (originalRelation === "manyToOne") {
    return "oneToMany";
  }
  if (originalRelation === "oneToMany") {
    return "manyToOne";
  }
  return originalRelation;
};
var findAttributeIndex = (type, attributeToFind) => {
  return type.attributes.findIndex(({ name }) => name === attributeToFind);
};
var getType = (state, { forTarget, targetUid }) => {
  return forTarget === "contentType" ? state.contentTypes[targetUid] : state.components[targetUid];
};
var setStatus = (type, status) => {
  switch (type.status) {
    case "NEW":
    case "REMOVED": {
      break;
    }
    default: {
      type.status = status;
    }
  }
};
var getNewStatus = (oldStatus, newStatus) => {
  if (oldStatus === "NEW" || oldStatus === "REMOVED") {
    return oldStatus;
  }
  return newStatus;
};
var setAttributeStatus = (attribute, status) => {
  attribute.status = getNewStatus(attribute.status, status);
};
var createAttribute = (properties) => {
  return {
    ...properties,
    status: "NEW"
  };
};
var setAttributeAt = (type, index, attribute) => {
  const previousAttribute = type.attributes[index];
  const newStatus = getNewStatus(previousAttribute.status, "CHANGED");
  type.attributes[index] = {
    ...attribute,
    status: newStatus
  };
  setStatus(type, "CHANGED");
};
var pushAttribute = (type, attribute) => {
  type.attributes.push(attribute);
  setStatus(type, "CHANGED");
};
var removeAttributeAt = (type, index) => {
  const attr = type.attributes[index];
  setStatus(type, "CHANGED");
  if (attr.status === "NEW") {
    type.attributes.splice(index, 1);
  } else {
    setAttributeStatus(attr, "REMOVED");
  }
};
var replaceAttributeAt = (type, index, attribute) => {
  type.attributes[index] = attribute;
  setStatus(type, "CHANGED");
};
var removeAttributeByName = (type, name) => {
  const idx = type.attributes.findIndex((attr2) => attr2.name === name);
  const attr = type.attributes[idx];
  setStatus(type, "CHANGED");
  if (attr.status === "NEW") {
    type.attributes.splice(idx, 1);
  } else {
    setAttributeStatus(attr, "REMOVED");
  }
};
var updateType = (type, data) => {
  (0, import_merge.default)(type, data);
  setStatus(type, "CHANGED");
};
var slice = createUndoRedoSlice({
  name: "data-manager",
  initialState,
  reducers: {
    init: (state, action) => {
      const { components, contentTypes, reservedNames } = action.payload;
      state.components = components;
      state.initialComponents = components;
      state.initialContentTypes = contentTypes;
      state.contentTypes = contentTypes;
      state.reservedNames = reservedNames;
      state.isLoading = false;
    },
    createComponentSchema: (state, action) => {
      const { uid, data, componentCategory } = action.payload;
      const newSchema = {
        uid,
        status: "NEW",
        category: componentCategory,
        modelName: data.displayName,
        globalId: data.displayName,
        info: {
          icon: data.icon,
          displayName: data.displayName
        },
        attributes: [],
        modelType: "component"
      };
      state.components[uid] = newSchema;
    },
    createSchema: (state, action) => {
      const { uid, data } = action.payload;
      const { displayName, singularName, pluralName, kind, draftAndPublish, pluginOptions } = data;
      const newSchema = {
        uid,
        status: "NEW",
        visible: true,
        modelType: "contentType",
        restrictRelationsTo: null,
        attributes: [],
        kind,
        modelName: displayName,
        globalId: displayName,
        options: {
          draftAndPublish
        },
        info: {
          displayName,
          singularName,
          pluralName
        },
        pluginOptions
      };
      state.contentTypes[uid] = newSchema;
    },
    addAttribute: (state, action) => {
      const { attributeToSet, forTarget, targetUid } = action.payload;
      const type = getType(state, {
        forTarget,
        targetUid
      });
      const attribute = createAttribute((0, import_omit.default)(attributeToSet, "createComponent"));
      if (attribute.type === "relation") {
        const target = attribute.target;
        const targetAttribute = attribute.targetAttribute || null;
        const relation = attribute.relation;
        const relationType = getRelationType(relation, targetAttribute);
        const isBidirectionalRelation = ![
          "oneWay",
          "manyWay"
        ].includes(relationType);
        if (isBidirectionalRelation) {
          const oppositeAttribute = createAttribute({
            name: targetAttribute,
            relation: getOppositeRelation(relationType),
            target: type.uid,
            targetAttribute: attribute.name,
            type: "relation",
            private: attribute.private
          });
          const targetType = getType(state, {
            forTarget,
            targetUid: target
          });
          pushAttribute(targetType, oppositeAttribute);
        }
      }
      pushAttribute(type, attribute);
      setStatus(type, "CHANGED");
    },
    moveAttribute: (state, action) => {
      const { forTarget, targetUid, from, to } = action.payload;
      const type = getType(state, {
        forTarget,
        targetUid
      });
      const attribute = type.attributes[from];
      type.attributes.splice(from, 1);
      type.attributes.splice(to, 0, attribute);
      setStatus(type, "CHANGED");
    },
    addCustomFieldAttribute: (state, action) => {
      const { attributeToSet, forTarget, targetUid } = action.payload;
      const type = getType(state, {
        forTarget,
        targetUid
      });
      pushAttribute(type, createAttribute(attributeToSet));
    },
    addCreatedComponentToDynamicZone: (state, action) => {
      const { dynamicZoneTarget, componentsToAdd, forTarget, targetUid } = action.payload;
      const type = getType(state, {
        forTarget,
        targetUid
      });
      const dzAttributeIndex = findAttributeIndex(type, dynamicZoneTarget);
      const attr = type.attributes[dzAttributeIndex];
      componentsToAdd.forEach((componentUid) => {
        attr.components.push(componentUid);
      });
      setAttributeStatus(attr, "CHANGED");
      setStatus(type, "CHANGED");
    },
    changeDynamicZoneComponents: (state, action) => {
      const { dynamicZoneTarget, newComponents, forTarget, targetUid } = action.payload;
      const type = getType(state, {
        forTarget,
        targetUid
      });
      const dzAttributeIndex = findAttributeIndex(type, dynamicZoneTarget);
      const attr = type.attributes[dzAttributeIndex];
      const currentDZComponents = attr.components;
      const updatedComponents = makeUnique([
        ...currentDZComponents,
        ...newComponents
      ]);
      setStatus(type, "CHANGED");
      setAttributeStatus(attr, "CHANGED");
      attr.components = updatedComponents;
    },
    editAttribute: (state, action) => {
      const { name, attributeToSet, forTarget, targetUid } = action.payload;
      const type = getType(state, {
        forTarget,
        targetUid
      });
      const initialAttributeIndex = findAttributeIndex(type, name);
      if (initialAttributeIndex === -1) {
        return;
      }
      const previousAttribute = type.attributes[initialAttributeIndex];
      setAttributeAt(type, initialAttributeIndex, attributeToSet);
      if (previousAttribute.type !== attributeToSet.type) {
        return;
      }
      if (previousAttribute.type !== "relation" || attributeToSet.type !== "relation") {
        return;
      }
      const previousTarget = getType(state, {
        forTarget: "contentType",
        targetUid: previousAttribute.target
      });
      const newTarget = getType(state, {
        forTarget: "contentType",
        targetUid: attributeToSet.target
      });
      const previousTargetAttributeIndex = findAttributeIndex(previousTarget, previousAttribute.targetAttribute ?? "");
      if (previousAttribute.targetAttribute) {
        removeAttributeByName(previousTarget, previousAttribute.targetAttribute);
      }
      const newRelationType = getRelationType(attributeToSet.relation, attributeToSet.targetAttribute);
      const isBidirectionnal = !ONE_SIDE_RELATIONS.includes(newRelationType);
      if (isBidirectionnal) {
        const newTargetAttribute = {
          name: attributeToSet.targetAttribute,
          type: "relation",
          relation: getOppositeRelation(attributeToSet.relation),
          targetAttribute: attributeToSet.name,
          target: type.uid,
          private: previousAttribute.private ?? attributeToSet.private,
          pluginOptions: previousAttribute.pluginOptions ?? attributeToSet.pluginOptions,
          status: "CHANGED"
        };
        if (previousTargetAttributeIndex !== -1 && previousTarget.uid === newTarget.uid) {
          replaceAttributeAt(newTarget, previousTargetAttributeIndex, newTargetAttribute);
        } else {
          pushAttribute(newTarget, {
            ...newTargetAttribute,
            status: "NEW"
          });
        }
      }
    },
    editCustomFieldAttribute: (state, action) => {
      const { forTarget, targetUid, name, attributeToSet } = action.payload;
      const initialAttributeName = name;
      const type = getType(state, {
        forTarget,
        targetUid
      });
      const initialAttributeIndex = findAttributeIndex(type, initialAttributeName);
      setAttributeAt(type, initialAttributeIndex, attributeToSet);
    },
    reloadPlugin: () => {
      return initialState;
    },
    removeComponentFromDynamicZone: (state, action) => {
      const { dzName, componentToRemoveIndex, forTarget, targetUid } = action.payload;
      const type = forTarget === "contentType" ? state.contentTypes[targetUid] : state.components[targetUid];
      if (!type) {
        return;
      }
      const dzAttributeIndex = findAttributeIndex(type, dzName);
      const attr = type.attributes[dzAttributeIndex];
      setStatus(type, "CHANGED");
      setAttributeStatus(attr, "CHANGED");
      attr.components.splice(componentToRemoveIndex, 1);
    },
    removeField: (state, action) => {
      const { forTarget, targetUid, attributeToRemoveName } = action.payload;
      const type = getType(state, {
        forTarget,
        targetUid
      });
      const attributeToRemoveIndex = findAttributeIndex(type, attributeToRemoveName);
      const attribute = type.attributes[attributeToRemoveIndex];
      if (attribute.type === "relation") {
        const { target, relation, targetAttribute: targetAttributeName } = attribute;
        const relationType = getRelationType(relation, targetAttributeName);
        const isBidirectionnal = !ONE_SIDE_RELATIONS.includes(relationType);
        if (isBidirectionnal && targetAttributeName) {
          const targetContentType = getType(state, {
            forTarget,
            targetUid: target
          });
          const targetAttributeIndex = findAttributeIndex(targetContentType, targetAttributeName);
          removeAttributeAt(targetContentType, targetAttributeIndex);
        }
      }
      type.attributes.forEach((attribute2) => {
        if (attribute2.type === "uid") {
          if (attribute2.targetField === attributeToRemoveName) {
            delete attribute2.targetField;
          }
        }
      });
      removeAttributeAt(type, attributeToRemoveIndex);
    },
    // only edits a component in practice
    updateComponentSchema: (state, action) => {
      const { data, uid } = action.payload;
      const type = state.components[uid];
      if (!type) {
        return;
      }
      updateType(type, {
        info: {
          displayName: data.displayName,
          icon: data.icon
        }
      });
    },
    updateComponentUid: (state, action) => {
      const { newComponentUID, uid } = action.payload;
      const type = state.components[uid];
      if (!type || type.status !== "NEW") {
        return;
      }
      if (newComponentUID !== uid) {
        const newType = {
          ...type,
          uid: newComponentUID
        };
        state.components[newComponentUID] = newType;
        delete state.components[uid];
        Object.keys(state.contentTypes).forEach((contentTypeUid) => {
          const contentType = state.contentTypes[contentTypeUid];
          contentType.attributes.forEach((attribute) => {
            if (attribute.type === "dynamiczone") {
              const newComponents = attribute.components.map((component) => {
                if (component === uid) {
                  return newComponentUID;
                }
                return component;
              });
              attribute.components = newComponents;
            }
          });
          contentType.attributes.forEach((attribute) => {
            if (attribute.type === "component" && attribute.component === uid) {
              attribute.component = newComponentUID;
            }
          });
        });
        Object.keys(state.components).forEach((componentUid) => {
          const component = state.components[componentUid];
          component.attributes.forEach((attribute) => {
            if (attribute.type === "component" && attribute.component === uid) {
              attribute.component = newComponentUID;
            }
          });
        });
      }
    },
    updateSchema: (state, action) => {
      const { data, uid } = action.payload;
      const { displayName, kind, draftAndPublish, pluginOptions } = data;
      const type = state.contentTypes[uid];
      if (!type) {
        return;
      }
      updateType(type, {
        info: {
          displayName
        },
        kind,
        options: {
          draftAndPublish
        },
        pluginOptions
      });
    },
    deleteComponent: (state, action) => {
      const uid = action.payload;
      if (state.components[uid].status === "NEW") {
        delete state.components[uid];
      } else {
        setStatus(state.components[uid], "REMOVED");
      }
      Object.keys(state.contentTypes).forEach((contentTypeUid) => {
        const contentType = state.contentTypes[contentTypeUid];
        contentType.attributes.forEach((attribute) => {
          if (attribute.type === "dynamiczone") {
            const newComponents = attribute.components.filter((component) => component !== uid);
            attribute.components = newComponents;
          }
        });
        contentType.attributes.forEach((attribute) => {
          if (attribute.type === "component" && attribute.component === uid) {
            removeAttributeByName(contentType, attribute.name);
          }
        });
      });
      Object.keys(state.components).forEach((componentUid) => {
        const component = state.components[componentUid];
        component.attributes.forEach((attribute) => {
          if (attribute.type === "component" && attribute.component === uid) {
            removeAttributeByName(component, attribute.name);
          }
        });
      });
    },
    deleteContentType: (state, action) => {
      const uid = action.payload;
      const type = state.contentTypes[uid];
      if (type.status === "NEW") {
        delete state.contentTypes[uid];
      } else {
        setStatus(type, "REMOVED");
      }
      Object.keys(state.components).forEach((componentUid) => {
        const component = state.components[componentUid];
        component.attributes.forEach((attribute) => {
          if (attribute.type === "relation" && attribute.target === uid) {
            removeAttributeByName(component, attribute.name);
          }
        });
      });
      Object.keys(state.contentTypes).forEach((contentTypeUid) => {
        const contentType = state.contentTypes[contentTypeUid];
        contentType.attributes.forEach((attribute) => {
          if (attribute.type === "relation" && attribute.target === uid) {
            removeAttributeByName(contentType, attribute.name);
          }
        });
      });
    },
    applyChange(state, reducerAction) {
      var _a, _b;
      const { action, schema } = reducerAction.payload;
      switch (action) {
        case "add":
          {
            const uid = schema.uid;
            if (schema.modelType === "component") {
              state.components[uid] = schema;
            } else {
              state.contentTypes[uid] = schema;
            }
          }
          break;
        case "update":
          {
            const uid = schema.uid;
            if (schema.modelType === "component") {
              const component = state.components[uid];
              state.components[uid] = {
                ...schema,
                status: (component == null ? void 0 : component.status) === "NEW" ? "NEW" : schema.status
              };
            } else {
              const contentType = state.contentTypes[uid];
              state.contentTypes[uid] = {
                ...schema,
                status: (contentType == null ? void 0 : contentType.status) === "NEW" ? "NEW" : schema.status
              };
            }
          }
          break;
        case "delete": {
          const uid = schema.uid;
          const isComponent = schema.modelType === "component";
          if (isComponent) {
            const exists = state.components[uid];
            if (!exists) {
              return;
            }
            const isUnsaved = ((_a = state.components[uid]) == null ? void 0 : _a.status) === "NEW";
            if (isUnsaved) {
              delete state.components[uid];
            } else {
              state.components[uid].status = "REMOVED";
            }
          } else {
            const exists = state.contentTypes[uid];
            if (!exists) {
              return;
            }
            const isUnsaved = ((_b = state.contentTypes[uid]) == null ? void 0 : _b.status) === "NEW";
            if (isUnsaved) {
              delete state.contentTypes[uid];
            } else {
              state.contentTypes[uid].status = "REMOVED";
            }
          }
          break;
        }
      }
    }
  }
}, {
  limit: 50,
  excludeActionsFromHistory: [
    "reloadPlugin",
    "init"
  ],
  stateSelector: (state) => {
    if (!state) {
      return {};
    }
    return {
      components: state.components,
      contentTypes: state.contentTypes
    };
  },
  discard: (state) => {
    state.components = state.initialComponents;
    state.contentTypes = state.initialContentTypes;
  }
});
var { reducer, actions } = slice;

// node_modules/@strapi/content-type-builder/dist/admin/utils/nameToSlug.mjs
var import_slugify = __toESM(require_slugify(), 1);
var nameToSlug = (name) => (0, import_slugify.default)(name, {
  separator: "-"
});

// node_modules/@strapi/content-type-builder/dist/admin/components/FormModal/utils/createUid.mjs
var createUid = (name) => {
  const modelName = nameToSlug(name);
  return `api::${modelName}.${modelName}`;
};
var createComponentUid = (name, category) => {
  return `${nameToSlug(category)}.${nameToSlug(name)}`;
};

// node_modules/@strapi/content-type-builder/dist/admin/components/FormModal/reducer.mjs
var import_set = __toESM(require_set(), 1);
var import_snakeCase = __toESM(require_snakeCase(), 1);
var import_pluralize = __toESM(require_pluralize(), 1);

// node_modules/@strapi/content-type-builder/dist/admin/components/FormModal/utils/customFieldDefaultOptionsReducer.mjs
var customFieldDefaultOptionsReducer = (acc, option) => {
  if (option.items) {
    return option.items.reduce(customFieldDefaultOptionsReducer, acc);
  }
  if ("defaultValue" in option) {
    const { name, defaultValue } = option;
    acc.push({
      name,
      defaultValue
    });
  }
  return acc;
};

// node_modules/@strapi/content-type-builder/dist/admin/components/FormModal/utils/relations.mjs
var shouldPluralizeName = (nature) => [
  "manyToMany",
  "oneToMany",
  "manyWay"
].includes(nature) ? 2 : 1;
var shouldPluralizeTargetAttribute = (nature) => [
  "manyToMany",
  "manyToOne"
].includes(nature) ? 2 : 1;

// node_modules/@strapi/content-type-builder/dist/admin/components/FormModal/reducer.mjs
var initialState2 = {
  formErrors: {},
  modifiedData: {},
  initialData: {},
  componentToCreate: {},
  isCreatingComponentWhileAddingAField: false
};
var slice2 = createSlice({
  name: "formModal",
  initialState: initialState2,
  reducers: {
    onChange: (state, action) => {
      const { keys, value } = action.payload;
      const obj = state.modifiedData;
      const hasDefaultValue = Boolean(obj.default);
      if (hasDefaultValue && keys.length === 1 && keys.includes("type")) {
        const previousType = obj.type;
        if (previousType && [
          "date",
          "datetime",
          "time"
        ].includes(previousType)) {
          delete state.modifiedData.default;
        }
      }
      (0, import_set.default)(state, [
        "modifiedData",
        ...keys
      ], value);
    },
    onChangeRelationTarget: (state, action) => {
      const { target: { oneThatIsCreatingARelationWithAnother, selectedContentTypeFriendlyName, targetContentTypeAllowedRelations, value } } = action.payload;
      let didChangeRelationTypeBecauseOfRestrictedRelation = false;
      let changedRelationType = null;
      (0, import_set.default)(state, [
        "modifiedData",
        "target"
      ], value);
      const modifiedData = state.modifiedData;
      if (Array.isArray(targetContentTypeAllowedRelations)) {
        const currentRelationType = getRelationType(modifiedData.relation, modifiedData.targetAttribute);
        if (currentRelationType && !targetContentTypeAllowedRelations.includes(currentRelationType)) {
          const relationToSet = targetContentTypeAllowedRelations[0];
          didChangeRelationTypeBecauseOfRestrictedRelation = true;
          changedRelationType = relationToSet;
          if (relationToSet === "oneWay") {
            (0, import_set.default)(state, [
              "modifiedData",
              "relation"
            ], "oneToOne");
          } else if (relationToSet === "manyWay") {
            (0, import_set.default)(state, [
              "modifiedData",
              "relation"
            ], "oneToMany");
          } else {
            (0, import_set.default)(state, [
              "modifiedData",
              "relation"
            ], relationToSet);
          }
        }
      }
      let nameToSet;
      if (didChangeRelationTypeBecauseOfRestrictedRelation && changedRelationType) {
        nameToSet = (0, import_pluralize.default)((0, import_snakeCase.default)(nameToSlug(selectedContentTypeFriendlyName)), shouldPluralizeName(changedRelationType));
      } else {
        nameToSet = (0, import_pluralize.default)((0, import_snakeCase.default)(nameToSlug(selectedContentTypeFriendlyName)), shouldPluralizeName(modifiedData.relation));
      }
      (0, import_set.default)(state, [
        "modifiedData",
        "name"
      ], nameToSet);
      const currentTargetAttribute = state.modifiedData.targetAttribute;
      if (currentTargetAttribute === null) {
        return;
      }
      if (didChangeRelationTypeBecauseOfRestrictedRelation && changedRelationType && [
        "oneWay",
        "manyWay"
      ].includes(changedRelationType)) {
        (0, import_set.default)(state, [
          "modifiedData",
          "targetAttribute"
        ], null);
        return;
      }
      const targetAttributeToSet = (0, import_pluralize.default)((0, import_snakeCase.default)(nameToSlug(oneThatIsCreatingARelationWithAnother)), shouldPluralizeTargetAttribute(modifiedData.relation));
      (0, import_set.default)(state, [
        "modifiedData",
        "targetAttribute"
      ], targetAttributeToSet);
    },
    onChangeRelationType: (state, action) => {
      const { target: { oneThatIsCreatingARelationWithAnother, value } } = action.payload;
      const currentName = state.modifiedData.name;
      if (![
        "oneWay",
        "manyWay"
      ].includes(value)) {
        (0, import_set.default)(state, [
          "modifiedData",
          "relation"
        ], value);
        const currentTargetAttribute = state.modifiedData.targetAttribute;
        (0, import_set.default)(state, [
          "modifiedData",
          "name"
        ], (0, import_pluralize.default)((0, import_snakeCase.default)(nameToSlug(currentName)), shouldPluralizeName(value)));
        (0, import_set.default)(state, [
          "modifiedData",
          "targetAttribute"
        ], (0, import_pluralize.default)(currentTargetAttribute || (0, import_snakeCase.default)(nameToSlug(oneThatIsCreatingARelationWithAnother)), shouldPluralizeTargetAttribute(value)));
        return;
      }
      if (value === "oneWay") {
        (0, import_set.default)(state, [
          "modifiedData",
          "relation"
        ], "oneToOne");
        (0, import_set.default)(state, [
          "modifiedData",
          "targetAttribute"
        ], null);
        (0, import_set.default)(state, [
          "modifiedData",
          "name"
        ], (0, import_pluralize.default)((0, import_snakeCase.default)(currentName), 1));
        return;
      }
      (0, import_set.default)(state, [
        "modifiedData",
        "relation"
      ], "oneToMany");
      (0, import_set.default)(state, [
        "modifiedData",
        "targetAttribute"
      ], null);
      (0, import_set.default)(state, [
        "modifiedData",
        "name"
      ], (0, import_pluralize.default)((0, import_snakeCase.default)(currentName), 2));
    },
    resetProps: () => {
      return initialState2;
    },
    resetPropsAndSetFormForAddingAnExistingCompo: (state, action) => {
      const { options = {} } = action.payload;
      return {
        ...initialState2,
        modifiedData: {
          type: "component",
          repeatable: true,
          ...options
        }
      };
    },
    resetPropsAndSaveCurrentData: (state, action) => {
      const { options = {} } = action.payload;
      const componentToCreate = state.modifiedData.componentToCreate;
      const modifiedData = {
        displayName: componentToCreate.displayName,
        type: "component",
        repeatable: false,
        ...options,
        component: createComponentUid(componentToCreate.displayName, componentToCreate.category)
      };
      return {
        ...initialState2,
        componentToCreate,
        modifiedData,
        isCreatingComponentWhileAddingAField: state.modifiedData.createComponent
      };
    },
    resetPropsAndSetTheFormForAddingACompoToADz: (state) => {
      const createdDZ = state.modifiedData;
      const dataToSet = {
        ...createdDZ,
        createComponent: true,
        componentToCreate: {
          type: "component"
        }
      };
      return {
        ...initialState2,
        modifiedData: dataToSet
      };
    },
    setDataToEdit: (state, action) => {
      const { data } = action.payload;
      state.modifiedData = data;
      state.initialData = data;
    },
    setAttributeDataSchema: (state, action) => {
      const { isEditing } = action.payload;
      if (isEditing === true) {
        const { modifiedDataToSetForEditing } = action.payload;
        state.modifiedData = modifiedDataToSetForEditing;
        state.initialData = modifiedDataToSetForEditing;
        return;
      }
      const { attributeType, nameToSetForRelation, targetUid, step, options = {} } = action.payload;
      let dataToSet;
      if (attributeType === "component") {
        if (step === "1") {
          dataToSet = {
            type: "component",
            createComponent: true,
            componentToCreate: {
              type: "component"
            }
          };
        } else {
          dataToSet = {
            ...options,
            type: "component",
            repeatable: true
          };
        }
      } else if (attributeType === "dynamiczone") {
        dataToSet = {
          ...options,
          type: "dynamiczone",
          components: []
        };
      } else if (attributeType === "text") {
        dataToSet = {
          ...options,
          type: "string"
        };
      } else if (attributeType === "number" || attributeType === "date") {
        dataToSet = options;
      } else if (attributeType === "media") {
        dataToSet = {
          allowedTypes: [
            "images",
            "files",
            "videos",
            "audios"
          ],
          type: "media",
          multiple: true,
          ...options
        };
      } else if (attributeType === "enumeration") {
        dataToSet = {
          ...options,
          type: "enumeration",
          enum: []
        };
      } else if (attributeType === "relation") {
        dataToSet = {
          name: (0, import_snakeCase.default)(nameToSetForRelation),
          relation: "oneToOne",
          targetAttribute: null,
          target: targetUid,
          type: "relation"
        };
      } else {
        dataToSet = {
          ...options,
          type: attributeType,
          default: null
        };
      }
      state.modifiedData = dataToSet;
    },
    setCustomFieldDataSchema: (state, action) => {
      var _a, _b;
      const { payload } = action;
      if (payload.isEditing === true) {
        const { modifiedDataToSetForEditing } = action.payload;
        state.modifiedData = modifiedDataToSetForEditing;
        state.initialData = modifiedDataToSetForEditing;
        return;
      }
      const { customField, options = {} } = payload;
      state.modifiedData = {
        ...options,
        type: customField.type
      };
      const allOptions = [
        ...((_a = customField == null ? void 0 : customField.options) == null ? void 0 : _a.base) || [],
        ...((_b = customField == null ? void 0 : customField.options) == null ? void 0 : _b.advanced) || []
      ];
      const optionDefaults = allOptions.reduce(customFieldDefaultOptionsReducer, []);
      if (optionDefaults.length) {
        optionDefaults.forEach(({ name, defaultValue }) => (0, import_set.default)(state.modifiedData, name, defaultValue));
      }
    },
    setDynamicZoneDataSchema: (state, action) => {
      const { attributeToEdit } = action.payload;
      state.modifiedData = attributeToEdit;
      state.initialData = attributeToEdit;
    },
    setErrors: (state, action) => {
      state.formErrors = action.payload.errors;
    }
  }
});
var { actions: actions2, reducer: reducer2 } = slice2;

export {
  PERMISSIONS,
  MAX_COMPONENT_DEPTH,
  makeUnique,
  initialState,
  reducer,
  actions,
  require_slugify,
  nameToSlug,
  createUid,
  createComponentUid,
  initialState2,
  actions2,
  reducer2,
  AutoReloadOverlayBlockerProvider,
  useAutoReloadOverlayBlocker,
  require_arrayIncludesWith,
  require_baseUniq
};
//# sourceMappingURL=chunk-E5CPYX5J.js.map
